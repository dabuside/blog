<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>dabuside</title><description>blog</description><link>https://dabuside.github.io/</link><language>en</language><item><title>如何处理 npm 包中的静态资源</title><link>https://dabuside.github.io/posts/asset_in_npm_package/</link><guid isPermaLink="true">https://dabuside.github.io/posts/asset_in_npm_package/</guid><description>ship assets in a npm package</description><pubDate>Sat, 01 Apr 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Contents&lt;/h2&gt;
&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;:::note
该场景与如下 issue 是同一个问题&lt;/p&gt;
&lt;p&gt;https://github.com/webpack/webpack/issues/7353
:::&lt;/p&gt;
&lt;p&gt;大屏项目需要运行时远程加载业务组件，其中业务组件 npm 包涉及一些静态资源，如背景图，字体文件。之前的处理方式是，图片，字体打包成 base64 到业务组件的 js 中。&lt;/p&gt;
&lt;p&gt;一般情况下，组件内引用字体、图片等资源，打包为 js 文件时，直接导出资源的话，生成的 js 代码是将静态资源以相对路径的方式引用，所有的静态资源会存放到相对路径对应的文件夹中。&lt;/p&gt;
&lt;p&gt;这样做存在的问题是，组件打包后 js 中的相对路径是写死的，每个项目的静态资源存放路径又不一样，一旦项目的静态资源路径和组件 js 中的路径不一样，资源引用就失败了。&lt;/p&gt;
&lt;p&gt;我们在构建业务组件库 npm 包的时候，需要考虑如何处理这些静态资源。&lt;/p&gt;
&lt;p&gt;如下图中基础环状饼图为远程加载的业务组件，其中的蓝色背景图即为业务组件饼图所需的静态图片资源。
&lt;img src=&quot;demo.png&quot; alt=&quot;demo&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;业界方案&lt;/h2&gt;
&lt;p&gt;目前业界对 npm 包中静态资源的处理一般为两种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有静态资源打包成 base64 放入 js 文件中&lt;/li&gt;
&lt;li&gt;让用户自行决定如何引用静态资源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他们的缺陷也都很明显&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态资源转 base64 后体积会大30%。且需要图片+组件渲染代码资源一起下载后，才能渲染。效果不如先加载组件渲染，后请求图片来的丝滑。&lt;/li&gt;
&lt;li&gt;如 idux 的 svg 引用，需要让用户手动拷贝 svg 图片到静态资源文件夹下，再到代码中设置图标的加载函数。如果遇到业务组件库更新频繁的情况，操作上比较麻烦。&lt;/li&gt;
&lt;li&gt;业务组件后续会支持外部导入。外部导入的业务组件的静态资源可能和内部业务组件静态资源重名。&lt;/li&gt;
&lt;li&gt;业务组件的代码，在业务组件的目录内，业务组件的图片放在平台侧的静态文件夹下，等于在两个库分别管理图片和代码，版本管理不清晰，也容易误操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;我的方案&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;import.meta.url + new URL()&lt;/code&gt;去标记资源相对位置&lt;/p&gt;
&lt;p&gt;import.meta是&lt;strong&gt;ES2020&lt;/strong&gt;的新规范，import.meta对象提供模块加载相关的元数据。如该模块从哪里加载的。&lt;/p&gt;
&lt;p&gt;假设组件A的组件目录结构如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;componentA/
├─ index.js
├─ img.png
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，index.js的代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//若index.js从 ui.com/bigscreen/static/componentA/index.js加载，那么import.meta.url就是这个路径
//通过new URL拼装，可以实现相对路径指向
//img = ui.com/bigscreen/static/componentA/img.png
const img = new URL(&apos;./image.png&apos;, import.meta.url)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述一行代码即实现了从资源相对路径指向。&lt;/p&gt;
&lt;p&gt;这个方案比上述两个业界常见方案的优点是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组件文件和图片文件放在一起管理，比较清晰&lt;/li&gt;
&lt;li&gt;业务方使用组件，拷贝资源到静态资源文件夹&lt;/li&gt;
&lt;li&gt;业务方无需手动添加静态资源到对应目录&lt;/li&gt;
&lt;li&gt;为浏览器原生语法，兼容性chrome63+&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;兼容性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;esm场景，如通过&lt;code&gt;type=module&lt;/code&gt;方式加载的组件可以使用&lt;code&gt;import.meta.url&lt;/code&gt;属性
如ie支持，umd方式加载的脚本，可以使用相似属性&lt;code&gt;document.currentScript.src&lt;/code&gt;支持&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上述兼容转换可通过webpack5原生、rollup插件&lt;code&gt;@web/rollup-plugin-import-meta-assets&lt;/code&gt;支持。兼容esm，cjs，amd，umd，systemjs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;vite启动dev需要配置optimizedeps关闭对应npm包预构建 &lt;a href=&quot;https://github.com/vitejs/vite/issues/8427&quot;&gt;issue&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;静态资源引用声明语句必须写在顶端。即script加上马上运行的地方，不能写在setup函数等延迟执行的地方。因为&lt;code&gt;document.currentScript&lt;/code&gt;对象只在对应脚本正在解析执行的时候有效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>Babel 编译的 loose 模式简述</title><link>https://dabuside.github.io/posts/babel_loose_mode/</link><guid isPermaLink="true">https://dabuside.github.io/posts/babel_loose_mode/</guid><description>babel loose mode</description><pubDate>Wed, 20 Jan 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Contents&lt;/h2&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;我们都知道，&lt;code&gt;babel&lt;/code&gt; 可以将 &lt;code&gt;es6&lt;/code&gt; 的代码转换为 &lt;code&gt;es5&lt;/code&gt; 的代码。其中&lt;code&gt;presets&lt;/code&gt; 有两种模式可以选择。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将代码转换为最接近 &lt;code&gt;es6&lt;/code&gt; 规范的正常模式 &lt;code&gt;loose: false&lt;/code&gt;，他能保证转换前后的语义是 99% 一致的&lt;/li&gt;
&lt;li&gt;将代码转换为更简单的 &lt;code&gt;es5&lt;/code&gt; 模式 &lt;code&gt;loose: true&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们项目用的是 &lt;code&gt;loose: true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们举一个具体的例子&lt;/p&gt;
&lt;h2&gt;ES6 原生模式&lt;/h2&gt;
&lt;p&gt;下面 &lt;code&gt;es6&lt;/code&gt; 的 &lt;code&gt;class&lt;/code&gt; 语法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;运行结果为控制台输出&lt;code&gt;x,y&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    toString() {
        return `(${this.x}, ${this.y})`;
    }
}
const point = new Point(1,2);

//es6规范规定，class上面的方法是不可枚举的
for( let i in point ) { console.log(i) } //x,y
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;宽松模式&lt;/h2&gt;
&lt;p&gt;如果宽松模式 &lt;code&gt;loose:true&lt;/code&gt; 模式转换的代码&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;运行结果为控制台输出&lt;code&gt;x,y,toString&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var Point = /*#__PURE__*/function () {
  &quot;use strict&quot;;

  function Point(x, y) {
    this.x = x;
    this.y = y;
  }
  var _proto = Point.prototype;
  _proto.toString = function toString() {
    return &quot;(&quot; + this.x + &quot;, &quot; + this.y + &quot;)&quot;;
  };
  return Point;
}();
var point = new Point(1, 2);

for (var i in point) {
  console.log(i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;严格模式&lt;/h2&gt;
&lt;p&gt;如果是严格模式 &lt;code&gt;loose:false&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;运行结果为控制台输出&lt;code&gt;x,y&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;function _typeof(o) { &quot;@babel/helpers - typeof&quot;; return _typeof = &quot;function&quot; == typeof Symbol &amp;amp;&amp;amp; &quot;symbol&quot; == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o &amp;amp;&amp;amp; &quot;function&quot; == typeof Symbol &amp;amp;&amp;amp; o.constructor === Symbol &amp;amp;&amp;amp; o !== Symbol.prototype ? &quot;symbol&quot; : typeof o; }, _typeof(o); }
require(&quot;core-js/modules/es.symbol.js&quot;);
require(&quot;core-js/modules/es.symbol.description.js&quot;);
require(&quot;core-js/modules/es.symbol.iterator.js&quot;);
require(&quot;core-js/modules/es.symbol.to-primitive.js&quot;);
require(&quot;core-js/modules/es.error.cause.js&quot;);
require(&quot;core-js/modules/es.array.concat.js&quot;);
require(&quot;core-js/modules/es.array.iterator.js&quot;);
require(&quot;core-js/modules/es.date.to-primitive.js&quot;);
require(&quot;core-js/modules/es.number.constructor.js&quot;);
require(&quot;core-js/modules/es.object.to-string.js&quot;);
require(&quot;core-js/modules/es.string.iterator.js&quot;);
require(&quot;core-js/modules/web.dom-collections.iterator.js&quot;);
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(&quot;Cannot call a class as a function&quot;); }
function _defineProperties(e, r) { for (var t = 0; t &amp;lt; r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, &quot;value&quot; in o &amp;amp;&amp;amp; (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r &amp;amp;&amp;amp; _defineProperties(e.prototype, r), t &amp;amp;&amp;amp; _defineProperties(e, t), Object.defineProperty(e, &quot;prototype&quot;, { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, &quot;string&quot;); return &quot;symbol&quot; == _typeof(i) ? i : i + &quot;&quot;; }
function _toPrimitive(t, r) { if (&quot;object&quot; != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || &quot;default&quot;); if (&quot;object&quot; != _typeof(i)) return i; throw new TypeError(&quot;@@toPrimitive must return a primitive value.&quot;); } return (&quot;string&quot; === r ? String : Number)(t); }
var Point = /*#__PURE__*/function () {
  &quot;use strict&quot;;

  function Point(x, y) {
    _classCallCheck(this, Point);
    this.x = x;
    this.y = y;
  }
  return _createClass(Point, [{
    key: &quot;toString&quot;,
    value: function toString() {
      return &quot;(&quot;.concat(this.x, &quot;, &quot;).concat(this.y, &quot;)&quot;);
    }
  }]);
}();
var point = new Point(1, 2);
for (var i in point) {
  console.log(i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://babeljs.io/repl#?browsers=ie%2011&amp;amp;build=&amp;amp;builtIns=usage&amp;amp;corejs=3.21&amp;amp;spec=false&amp;amp;loose=false&amp;amp;code_lz=MYGwhgzhAEAKD2BLAdgF2gbwFDV9Y8yEqATgK7CrwkAUAHgDTQCeAlJjnl6gBaIQA6OtAC80OgG5OXXL34DmollK4BfadCoBlUigDmNdthl4SAU1RkSyaAAMaAEgxzBdVUycuFq1rZV51dQIidAAHJDQlZDMAdzgI1BoARgYAJlYpLAAzahpoEAtoRCKbcJR0I3xCCHgCgRB4A0R2VWggA&amp;amp;debug=false&amp;amp;forceAllTransforms=false&amp;amp;modules=false&amp;amp;shippedProposals=false&amp;amp;evaluate=false&amp;amp;fileSize=false&amp;amp;timeTravel=false&amp;amp;sourceType=script&amp;amp;lineWrap=false&amp;amp;presets=env%2Cstage-3&amp;amp;prettier=false&amp;amp;targets=&amp;amp;version=7.24.10&amp;amp;externalPlugins=%40babel%2Fplugin-transform-parameters%407.23.3&amp;amp;assumptions=%7B%7D&quot;&gt;repl-link&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们可以观察到，宽松模式产生了比较简单的 &lt;code&gt;es5&lt;/code&gt; 代码，但是和规范定义有些差别。正常模式则会将这些方法定义翻译为 &lt;code&gt;Object.defineProperty&lt;/code&gt; ，并设置成不可枚举，和直接运行 &lt;code&gt;es6&lt;/code&gt; 代码得到相同的结果。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;loose&lt;/code&gt; 模式可以产生更简单的代码，类似手写 &lt;code&gt;es6&lt;/code&gt; ，运行效率更高。如果后续使用 &lt;code&gt;es6&lt;/code&gt; 原生模式运行项目，可能会有意想不到的&lt;strong&gt;bug&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;正常模式使用复杂的 &lt;code&gt;es5&lt;/code&gt; 代码去模拟 &lt;code&gt;es6&lt;/code&gt; 的规范，运行效率稍稍下降，但如果后续使用 &lt;code&gt;es6&lt;/code&gt; 原生模式运行项目，行为基本上是一致的。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>自动分析代码改动影响面</title><link>https://dabuside.github.io/posts/dependency_analyze/</link><guid isPermaLink="true">https://dabuside.github.io/posts/dependency_analyze/</guid><description>dependency analyze</description><pubDate>Sat, 15 May 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Contents&lt;/h2&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;大项目规矩实在太多了，修 &lt;code&gt;bug&lt;/code&gt; 需要详细描述问题根因，如何解决，测试步骤，影响范围，是否自测。经常上库几行代码，上库描述信息要写&lt;strong&gt;半小时&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;其中，前端对于其他页面的影响是这样规定的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果修改了&lt;code&gt;common_components&lt;/code&gt;中的全局组件，则需要对&lt;strong&gt;所有引用到组件的页面&lt;/strong&gt;进行测试，并列出所有影响到的页面给到测试&lt;/li&gt;
&lt;li&gt;如果仅修改了某个页面的内容，则需测试对应页面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;项目的目录结构大致如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;src/
├── common_components/
│   ├── global_component1.js
│   └── global_component2.js
└── pages/
    ├── page1/
    │   ├── index.js
    │   ├── local_component1.js
    │   └── local_component2.js
    └── page2/
        ├── index.js
        ├── local_component3.js
        └── local_component4.js
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果一些全局组件的被引用页面比较多，人工查询会非常耗时，而且容易漏&lt;/li&gt;
&lt;li&gt;随着页面的上线/下线，有些全局组件，实际上只有1处引用，没有全局组件的含义了。那么开发人员和审核人员不用费时费力找引用关系了&lt;/li&gt;
&lt;li&gt;有些开发不守规矩，本地组件也存在全局组件类似的功能，比如 &lt;code&gt;page1&lt;/code&gt; 页面下使用了 &lt;code&gt;page2&lt;/code&gt; 目录中的 &lt;code&gt;local_component&lt;/code&gt; 组件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;思考&lt;/h2&gt;
&lt;p&gt;由于代码比较统一，都是用 &lt;code&gt;CommonJS&lt;/code&gt; 处理的模块引用关系，想写一个工具处理这些引用分析，自动输出修改测试建议&lt;/p&gt;
&lt;p&gt;经过一番搜索，了解到有一个叫&lt;a href=&quot;https://github.com/pahen/madge&quot;&gt;madge&lt;/a&gt;的工具，可以自动分析 &lt;code&gt;CJS&lt;/code&gt; 和 &lt;code&gt;ESM&lt;/code&gt; 的文件引用关系&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./madge.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;直接进行 &lt;code&gt;API&lt;/code&gt; 调用的话，可以得到一个一维数组的文件直接引用关系&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &quot;src/pages/page1/index.js&quot;: [
    &quot;src/pages/page1/local_component1.js&quot;,
    &quot;src/pages/page1/local_component2.js&quot;,
    &quot;src/common_components/global_component1.js&quot;
  ],
  &quot;src/pages/page1/index.js&quot;: [
    &quot;src/pages/page1/local_component3.js&quot;,
    &quot;src/pages/page1/local_component4.js&quot;
  ]
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们吧这里的样式文件（css，less）去掉，再把这个一维数组组装成引用链，深度1的节点为直接引用，深度2的节点以下的链则为间接引用&lt;/p&gt;
&lt;p&gt;这样，从一个或多个改动的文件，可以定位到最终影响的某个路由页面。&lt;/p&gt;
&lt;p&gt;那么，根据项目的路由表，做出引用链终点数组，如果引用链索引到上述的某个路由文件，则输出对应的路由名称&lt;/p&gt;
&lt;p&gt;则每个改动文件可以对应到如下三种情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到找到一个或多个最终路由目录&lt;/li&gt;
&lt;li&gt;没有文件引用该文件，或者该文件最终没有被路由引用可能是这个文件是项目的冗余文件，或者路由入口被暂时注释导致&lt;/li&gt;
&lt;li&gt;出现循环引用，中止递归待排查&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在流水线上做改动，不影响原来任何功能。&lt;/li&gt;
&lt;li&gt;自动化部分功能。由以前的提交人自行描述改动分析改为自动化分析改动影响面。节省了人员时间。&lt;/li&gt;
&lt;li&gt;不限制代码语言、代码仓。如需在其他产品线引入功能。仅需修改输出路由表函数即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自动化程度不足。只有部分自动化。输出的是程序分析的改动影响路由。具体如何影响，还是需要人工判断。&lt;/li&gt;
&lt;li&gt;存在无法检测到的场景。如&lt;code&gt;EXT&lt;/code&gt;，&lt;code&gt;windows&lt;/code&gt;等全局变量的使用。那么无法确定影响面。&lt;/li&gt;
&lt;li&gt;存在无法检测到的场景，如动态引用，&lt;code&gt;require(var)&lt;/code&gt;, &lt;code&gt;require.context()&lt;/code&gt;。那么无法识别到当前文件的完整引用关系数据。&lt;/li&gt;
&lt;li&gt;粒度粗。思考能否以函数、变量为维度去分析改动影响面。插桩？istanbul？&lt;/li&gt;
&lt;/ol&gt;
</content:encoded></item><item><title>视觉稿生成代码</title><link>https://dabuside.github.io/posts/design_to_code/</link><guid isPermaLink="true">https://dabuside.github.io/posts/design_to_code/</guid><description>design to code</description><pubDate>Sat, 20 Jul 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Contents&lt;/h2&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近，团队做了个视觉稿生成代码的工具。这个工具可以一键将 &lt;a href=&quot;https://mastergo.com/&quot;&gt;mastergo平台&lt;/a&gt; 设计稿平台的设计稿变成可用代码。与 mastergo 平台的开发人员对接的时候，他们都表示功能比他们自己的 d2c 还要好，笑。&lt;/p&gt;
&lt;p&gt;整体工作流程是这样的&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户打开设计稿，选定节点，点击浏览器插件，选择代码生成&lt;/li&gt;
&lt;li&gt;浏览器插件通过设计稿对应的 API 获取选中的节点信息传递至服务器&lt;/li&gt;
&lt;li&gt;服务器根据节点信息以及图像特征处理成初步图元信息树，返回 url 链接给浏览器插件&lt;/li&gt;
&lt;li&gt;浏览器插件打开 url，用户修改识别错误的节点名称、层级、属性，发送最终图元信息树给服务器&lt;/li&gt;
&lt;li&gt;服务器根据最终图元信息树，返回代码片段&lt;/li&gt;
&lt;li&gt;&lt;code&gt;monaco-editor&lt;/code&gt;组件展示最终代码，&lt;code&gt;vue-repl&lt;/code&gt;组件展示代码运行效果&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文将介绍怎么由图元信息生成可用前端代码。&lt;/p&gt;
&lt;h2&gt;了解需求&lt;/h2&gt;
&lt;p&gt;我司的业务以B端场景为主，基本上每个页面都需要长期维护。所以期望生成代码的风格必须和项目风格是类似的&lt;/p&gt;
&lt;p&gt;但是同一个视觉稿，简单的弹窗功能，在不同的写法、组件库下，最终的代码差异极大&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;simple_modal.png&quot; alt=&quot;simple_modal&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;vue class component 写法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
    &amp;lt;sf-form class=&quot;modal-form&quot; ref=&quot;form&quot; label-width=&quot;auto&quot; input-width=&quot;auto&quot;&amp;gt;
        &amp;lt;sf-form-item tip-text=&quot;&quot; :label-text=&quot;$i(&apos;标签名称&apos;)&quot;&amp;gt;
            &amp;lt;sf-input
                :input-width=&quot;326&quot;
                :placeholder=&quot;$i(&apos;请输入模板名称&apos;)&quot;
                name=&quot;value&quot;
                v-model=&quot;form.tagName&quot;
                v-model.number=&quot;value&quot;
            &amp;gt;&amp;lt;/sf-input&amp;gt;
        &amp;lt;/sf-form-item&amp;gt;
        &amp;lt;sf-form-item tip-text=&quot;&quot; :label-text=&quot;$i(&apos;自定义名称&apos;)&quot;&amp;gt;
            &amp;lt;sf-input
                :input-width=&quot;326&quot;
                :placeholder=&quot;$i(&apos;请输入描述（选填）&apos;)&quot;
                name=&quot;value&quot;
                v-model=&quot;form.customName&quot;
                v-model.number=&quot;value&quot;
            &amp;gt;&amp;lt;/sf-input&amp;gt;
        &amp;lt;/sf-form-item&amp;gt;
        &amp;lt;sf-form-item tip-text=&quot;&quot; :label-text=&quot;$i(&apos;启用标签&apos;)&quot;&amp;gt;
            &amp;lt;div class=&quot;ccode_alignItem__center ccode_justify__end form-formItem__toolbar&quot;&amp;gt;
                &amp;lt;div class=&quot;form-formItem__toolbar--round&quot;&amp;gt;&amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/sf-form-item&amp;gt;
    &amp;lt;/sf-form&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script lang=&quot;ts&quot;&amp;gt;
import { Vue, Component, Mixins } from &apos;vue-property-decorator&apos;;
import { $i } from &apos;mss/i18n&apos;;
import FormMixin from &apos;module/mod-common/form/index&apos;;

@Component
export default class MyComponent extends Mixins(FormMixin) {
    value = 1;

    private form = { tagName: &apos;&apos;, customName: &apos;&apos; };
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;define component 写法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
    &amp;lt;div class=&quot;pageContainer&quot;&amp;gt;
        &amp;lt;IxHeader&amp;gt;
            &amp;lt;IxRow justify=&quot;space-between&quot; align=&quot;center&quot; :wrap=&quot;false&quot; class=&quot;header-row&quot;&amp;gt;
                &amp;lt;IxCol class=&quot;row-col&quot;&amp;gt;
                    &amp;lt;span class=&quot;row-col&quot;&amp;gt;
                        {{ $i(&apos;production.module.add_search_condition&apos;) }}
                    &amp;lt;/span&amp;gt;
                &amp;lt;/IxCol&amp;gt;
                &amp;lt;IxCol flex=&quot;30px&quot; class=&quot;comp-image&quot;&amp;gt;&amp;lt;/IxCol&amp;gt;
            &amp;lt;/IxRow&amp;gt;
        &amp;lt;/IxHeader&amp;gt;
        &amp;lt;IxSpace :wrap=&quot;false&quot; vertical :size=&quot;44&quot; align=&quot;center&quot; class=&quot;space-content&quot;&amp;gt;
            &amp;lt;IxForm :colonless=&quot;false&quot; :labelCol=&quot;6&quot; class=&quot;space-form&quot; :control=&quot;formGroup&quot;&amp;gt;
                &amp;lt;IxFormItem :label=&quot;$i(&apos;production.module.label_name&apos;)&quot;&amp;gt;
                    &amp;lt;IxInput :placeholder=&quot;$i(&apos;production.module.enter_template_name&apos;)&quot; control=&quot;tagName&quot;&amp;gt;&amp;lt;/IxInput&amp;gt;
                &amp;lt;/IxFormItem&amp;gt;
                &amp;lt;IxFormItem :label=&quot;$i(&apos;production.module.custom_name&apos;)&quot;&amp;gt;
                    &amp;lt;IxInput
                        :placeholder=&quot;$i(&apos;production.module.enter_description_optional&apos;)&quot;
                        control=&quot;customName&quot;
                    &amp;gt;&amp;lt;/IxInput&amp;gt;
                &amp;lt;/IxFormItem&amp;gt;
                &amp;lt;IxFormItem :label=&quot;$i(&apos;production.module.enable_label&apos;)&quot;&amp;gt;
                    &amp;lt;div class=&quot;ccode_alignItem__center ccode_justify__end form-formItem__toolbar&quot;&amp;gt;
                        &amp;lt;div class=&quot;form-formItem__toolbar--round&quot;&amp;gt;&amp;lt;/div&amp;gt;
                    &amp;lt;/div&amp;gt;
                &amp;lt;/IxFormItem&amp;gt;
            &amp;lt;/IxForm&amp;gt;
            &amp;lt;IxSpace :wrap=&quot;false&quot; block justify=&quot;end&quot; class=&quot;space-space&quot;&amp;gt;
                &amp;lt;IxButton size=&quot;md&quot;&amp;gt;
                    {{ $i(&apos;global.ok.button&apos;) }}
                &amp;lt;/IxButton&amp;gt;
                &amp;lt;IxButton size=&quot;md&quot;&amp;gt;
                    {{ $i(&apos;global.cancel.button&apos;) }}
                &amp;lt;/IxButton&amp;gt;
            &amp;lt;/IxSpace&amp;gt;
        &amp;lt;/IxSpace&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script lang=&quot;ts&quot;&amp;gt;
import { name } from &apos;appLib/utils/validations/regexpIdux/name&apos;;
import { Validators, useFormGroup } from &apos;@idux-vue2/cdk/forms&apos;;
import { defineComponent } from &apos;@vue/composition-api&apos;;

export interface FormGroupType {
    tagName: string;
    customName: string;
}

export default defineComponent({
    setup(props, ctx) {
        const { maxLength } = Validators;

        const formGroup = useFormGroup&amp;lt;FormGroupType&amp;gt;({
            tagName: [&apos;&apos;, [name, maxLength(95)]],
            customName: [&apos;&apos;, maxLength(95)],
        });

        return {
            state,
            formGroup,
        };
    },
});
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;vue script setup 写法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;IxHeader&amp;gt;
            &amp;lt;IxRow justify=&quot;space-between&quot; align=&quot;center&quot; :wrap=&quot;false&quot;&amp;gt;
                &amp;lt;IxCol&amp;gt;
                    &amp;lt;span&amp;gt; 新增检索条件 &amp;lt;/span&amp;gt;
                &amp;lt;/IxCol&amp;gt;
                &amp;lt;IxCol flex=&quot;30px&quot;&amp;gt;&amp;lt;/IxCol&amp;gt;
            &amp;lt;/IxRow&amp;gt;
        &amp;lt;/IxHeader&amp;gt;
        &amp;lt;IxSpace :wrap=&quot;false&quot; vertical :size=&quot;44&quot; align=&quot;center&quot;&amp;gt;
            &amp;lt;IxForm :colonless=&quot;false&quot; :labelCol=&quot;6&quot; :control=&quot;formGroup&quot;&amp;gt;
                &amp;lt;IxFormItem label=&quot;标签名称&quot;&amp;gt;
                    &amp;lt;IxInput placeholder=&quot;请输入模板名称&quot; control=&quot;tagName&quot;&amp;gt;&amp;lt;/IxInput&amp;gt;
                &amp;lt;/IxFormItem&amp;gt;
                &amp;lt;IxFormItem label=&quot;自定义名称&quot;&amp;gt;
                    &amp;lt;IxInput placeholder=&quot;请输入描述（选填）&quot; control=&quot;customName&quot;&amp;gt;&amp;lt;/IxInput&amp;gt;
                &amp;lt;/IxFormItem&amp;gt;
                &amp;lt;IxFormItem label=&quot;启用标签&quot;&amp;gt;
                    &amp;lt;div&amp;gt;
                        &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
                    &amp;lt;/div&amp;gt;
                &amp;lt;/IxFormItem&amp;gt;
            &amp;lt;/IxForm&amp;gt;
            &amp;lt;IxSpace :wrap=&quot;false&quot; block justify=&quot;end&quot;&amp;gt;
                &amp;lt;IxButton size=&quot;md&quot;&amp;gt; 确定 &amp;lt;/IxButton&amp;gt;
                &amp;lt;IxButton size=&quot;md&quot;&amp;gt; 取消 &amp;lt;/IxButton&amp;gt;
            &amp;lt;/IxSpace&amp;gt;
        &amp;lt;/IxSpace&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script lang=&quot;ts&quot; setup&amp;gt;
import { Validators, useFormGroup } from &apos;@idux/cdk/forms&apos;;

export interface FormGroup {
    tagName: string;
    customName: string;
}

const formGroup = useFormGroup&amp;lt;FormGroup&amp;gt;({
    tagName: [&apos;&apos;, Validators.maxLength(95)],
    customName: [&apos;&apos;, Validators.maxLength(95)],
});
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;上游输入&lt;/h3&gt;
&lt;p&gt;举个最简单的例子，例如这个的输入框：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;schema.png&quot; alt=&quot;schema&quot; /&gt;&lt;/p&gt;
&lt;p&gt;扫描后可以得到下面的类似&lt;code&gt;VNode&lt;/code&gt;的 &lt;code&gt;schema&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &quot;component&quot;: &quot;IxForm&quot;,
    &quot;props&quot;: {
        &quot;labelCol&quot;: 4,
    },
    &quot;children&quot;: [
        {
            &quot;component&quot;: &quot;IxFormItem&quot;,
            &quot;props&quot;: {
                &quot;label&quot;: {
                    &quot;type&quot;: &quot;i18n&quot;,
                    &quot;key&quot;: &quot;i18n_key.platform_name&quot;,
                    &quot;value&quot;: &quot;平台名称&quot;,
                },
                &quot;colonless&quot;: false,
            },
            &quot;children&quot;: [
                {
                    &quot;component&quot;: &quot;IxInput&quot;,
                    &quot;props&quot;: {
                        &quot;placeholder&quot;: {
                            &quot;type&quot;: &quot;i18n&quot;,
                            &quot;key&quot;: &quot;i18n_key.input_placeholder&quot;,
                            &quot;value&quot;: &quot;请输入平台名称&quot;,
                        },
                    },
                    &quot;slots&quot;: {
                        &quot;suffix&quot;: [
                            {
                                &quot;component&quot;: &quot;IxIcon&quot;,
                                &quot;props&quot;: {
                                    &quot;name&quot;: &quot;info-circle&quot;
                                }
                            },
                        ],
                    },
                }
            ]
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Babel 简介&lt;/h2&gt;
&lt;p&gt;Babel 是一个 JavaScript 编译器，主要用于将现代 JavaScript 代码（如 ES6、ES7 等）转换为兼容较旧浏览器和环境的 JavaScript 代码。它的工作流程包括以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;解析（Parsing）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;词法分析（Lexical Analysis）&lt;/strong&gt;：将输入的代码字符串转换为一个个词法单元（token），每个词法单元代表一个最小的语法元素，如关键字、变量名、操作符等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;语法分析（Syntax Analysis）&lt;/strong&gt;：将词法单元序列转换为一个抽象语法树（AST）。AST 是一个树状结构，表示代码的语法结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;转换（Transformation）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;遍历和修改 AST&lt;/strong&gt;：对 AST 进行遍历，并根据需要进行修改。这个过程包括各种转换插件（plugins）的执行，每个插件负责一个特定的转换任务，如将箭头函数转换为普通函数，将类语法转换为函数构造等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;生成（Generation）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;代码生成（Code Generation）&lt;/strong&gt;：将修改后的 AST 转换回代码字符串，同时生成源映射（source map），以便在调试时能将转换后的代码映射回原始代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Babel 工作流程图&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt; +--------------+       +--------------+       +--------------+
 |              |       |              |       |              |
 |   Source     |       |   AST        |       |   Transformed|
 |   Code       | ----&amp;gt; |   Generation | ----&amp;gt; |   AST        |
 |              |       |              |       |              |
 +--------------+       +--------------+       +--------------+
                                |
                                |
                                V
                        +--------------+
                        |              |
                        |   Code       |
                        |   Generation |
                        |              |
                        +--------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;仿 Babel 流程生成代码&lt;/h2&gt;
&lt;p&gt;我们要做的工具和&lt;code&gt;babel&lt;/code&gt;十分类似&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;babel&lt;/code&gt;是将一种&lt;code&gt;语言&lt;/code&gt;转换为另一种&lt;code&gt;目标语言&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;视觉稿转代码&lt;/code&gt;是将&lt;code&gt;设计稿语言&lt;/code&gt;转换为&lt;code&gt;实际业务代码&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;babel&lt;/code&gt;与&lt;code&gt;视觉稿转代码&lt;/code&gt;都需要支持装载插件定义转换流程，指定编译目标&lt;code&gt;target&lt;/code&gt;，生成任意&lt;code&gt;目标语言代码&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于上游的输入就是 AST 了，不需要再进行解析流程&lt;/p&gt;
&lt;p&gt;我们设计一个这样的机制，插件可以在每个节点遍历的回调钩子中修改节点信息，以及以字符串形式往区块添加&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;gencode.png&quot; alt=&quot;gencode&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;遍历节点 AST Transformation&lt;/h3&gt;
&lt;p&gt;我们对&lt;code&gt;schema&lt;/code&gt;中的每个 AST 节点进行遍历，在遍历的过程中，给节点绑定不同的属性以及事件，不同组件库则处理成不同组件名&lt;/p&gt;
&lt;p&gt;遍历规则参考&lt;a href=&quot;https://github.com/babel/babel/tree/main/packages/babel-traverse&quot;&gt;@babel/traverse&lt;/a&gt;，回调方式参考&lt;code&gt;babel&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;同时，支持在遍历的过程中对节点进行删除、移动、添加、修改，&lt;strong&gt;遍历器会保证每个节点恰好被遍历一次&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;代码生成 Code Generation&lt;/h3&gt;
&lt;h4&gt;vue template&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;schema&lt;/code&gt;节点与&lt;code&gt;html&lt;/code&gt;节点均为 1: 1的对应关系，借助开源工具&lt;a href=&quot;https://github.com/posthtml/posthtml&quot;&gt;posthtml&lt;/a&gt;，仅需处理一下格式转换，即可直接序列化成&lt;code&gt;html&lt;/code&gt;字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
   {{ posthtml(schemaToHtmlTag(schema)) }}
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;vue script&lt;/h4&gt;
&lt;p&gt;我们对于每个文件，可以指定一个文件区块，比如&lt;code&gt;defineComponent&lt;/code&gt;样式的&lt;code&gt;vue script&lt;/code&gt;，我们指定如下四个区块，在插件定义的遍历函数钩子中，可以往如下区块&lt;strong&gt;以字符串形式&lt;/strong&gt;添加代码。亦可存储特征信息到全局&lt;code&gt;Context&lt;/code&gt;，待完成遍历后一次性将特征信息&lt;strong&gt;以字符串形式&lt;/strong&gt;序列化添加到如下区块中。以此来完成代码生成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;block.png&quot; alt=&quot;block&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;其他文件&lt;/h4&gt;
&lt;p&gt;诸如&lt;code&gt;ts&lt;/code&gt;,&lt;code&gt;i18n.yml&lt;/code&gt;,&lt;code&gt;css&lt;/code&gt;此类文件，则和上述&lt;code&gt;vue script&lt;/code&gt;的处理方式一致，&lt;/p&gt;
&lt;h3&gt;编写插件&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import { type GenCodePlugin, type VueHelper } from &apos;gencode-transform&apos;;

function formPlugin(): GenCodePlugin {
    return {

        // 约定：插件拥有唯一 name
        name: &apos;gcode-plugin-form&apos;,
        resolve(mod, ctx) {

            // 本插件只处理 vue 模块
            if (mod.ext !== &apos;vue&apos; || !mod.schema) {
                return;
            }

            // 获取协助代码生成的 helper
            const helper = ctx.getHelper&amp;lt;VueHelper&amp;gt;(mod);

            // 遍历 schema
            ctx.traverse(mod.schema, {

                /**
                 * 收集用到的组件，例如 IxForm 等；
                 * 将其放入 helper 的 importer 中，生成引入代码，如：
                 *
                 * import { IxForm, IxFormItem } from &apos;@idux-vue2&apos;;
                 */
                enter(path) {
                    if (/^Ix.+/.test(path.type)) {
                        helper.options.components.add(path.type);
                        helper.importer.add({
                            imported: path.type,
                            from: &apos;@idux-vue2&apos;,
                        });
                    }
                },

                /**
                 * 收集 i18n 信息，生成 i18n 词条文件
                 */
                exit(path) {
                    const props = path.schema.props ?? {};
                    const rawProps = path.raw?.props ?? props;
                    Object.keys(props)?.forEach(propKey =&amp;gt; {
                        if (props[propKey]?.type === &apos;i18n&apos;) {
                            ctx.i18n.add(
                                rawProps[propKey].key,
                                rawProps[propKey].value,
                            );
                            path.propsBind(propKey, `$i(&apos;${props[propKey].key}&apos;)`);
                        }
                    });
                },

                // 专门访问 IxForm 组件，设置 class name
                IxForm(path) {
                    // path.schema.props.class = &apos;wrapper&apos;;
                    path.propsSet(&apos;class&apos;, &apos;wrapper&apos;);
                },
            });

            // 生成 setup 代码
            helper.setup = true;

            // 写入简单的样式代码
            helper.style.lang = &apos;css&apos;;
            helper.style.code = `
                .wrapper {
                    height: 100%;
                }
            `;
        },
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;效果示例&lt;/h3&gt;
&lt;p&gt;根据上面的 schema 和插件，我们会得到下面的结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
    {
        &quot;ext&quot;: &quot;vue&quot;,
        &quot;filename&quot;: &quot;index.vue&quot;,
        &quot;code&quot;: &quot;...&quot;
    },
    {
        &quot;ext&quot;: &quot;yaml&quot;,
        &quot;filename&quot;: &quot;i18n.yaml&quot;,
        &quot;code&quot;: &quot;...&quot;
    }
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 vue 的代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
    &amp;lt;IxForm class=&quot;wrapper&quot; :labelCol=&quot;4&quot;&amp;gt;
        &amp;lt;IxFormItem :colonless=&quot;false&quot; :label=&quot;$i(&apos;i18n_key.platform_name&apos;)&quot;&amp;gt;
            &amp;lt;IxInput :placeholder=&quot;$i(&apos;i18n_key.input_placeholder&apos;)&quot;&amp;gt;
                &amp;lt;template #suffix&amp;gt;
                    &amp;lt;IxIcon name=&quot;info-circle&quot; /&amp;gt;
                &amp;lt;/template&amp;gt;
            &amp;lt;/IxInput&amp;gt;
        &amp;lt;/IxFormItem&amp;gt;
    &amp;lt;/IxForm&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script lang=&quot;ts&quot; setup&amp;gt;
import { IxForm, IxFormItem, IxInput, IxIcon } from &apos;@idux-vue2&apos;;
&amp;lt;/script&amp;gt;

&amp;lt;style lang=&quot;css&quot;&amp;gt;
.wrapper {
    height: 100%;
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;i18n 词条文件如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;i18n_key.platform_name&quot;: &quot;平台名称&quot;
&quot;i18n_key.input_placeholder&quot;: &quot;请输入平台名称&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;生成代码优化&lt;/h2&gt;
&lt;p&gt;使用 d2c 生成的代码，复制到项目中，有 &lt;code&gt;eslint&lt;/code&gt; 报错。落地场景约生成 250 行 vue 代码，有13 &lt;code&gt;eslint&lt;/code&gt; 报错。 业务人员反馈，吧生成出来的代码改到不报错，功能正常，和去项目模块 copy 相似代码后再进行修改，提效不明显。 使用我们内部工具生成出来代码一堆报错，在落地的时候会有很大的阻碍，业务人员会质疑我们工具不好用！心理上就会抵触使用。&lt;/p&gt;
&lt;h3&gt;eslint 问题分析&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;多余函数变量声明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;unused_function_param.png&quot; alt=&quot;unused_function_param&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;hook解构多余变量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;unused_hook_var.png&quot; alt=&quot;unused_hook_var&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;导入变量未使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;unused_import.png&quot; alt=&quot;unused_import&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中，声明变量未使用约占全部 &lt;code&gt;eslint&lt;/code&gt; 问题数量的 70%&lt;/p&gt;
&lt;p&gt;为什么不在插件侧按需声明变量呢？因为这样会使得代码的按需声明变得很复杂。变量声明有嵌套关系。&lt;/p&gt;
&lt;p&gt;举个例子，为了使得插件的编写简单，我们一般检测到存在&lt;code&gt;table&lt;/code&gt;场景，则自动注入全部&lt;code&gt;table&lt;/code&gt;场景相关的业务代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (视觉稿存在表格) {
    以字符串形式往 script 部分
    注入 分页逻辑
    注入 排序、筛选变化重新请求逻辑
    注入 勾选列和删除联动逻辑
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 hook解构多余变量 场景中，如果视觉稿中没有涉及删除的操作，那么&lt;code&gt;deleteFn&lt;/code&gt;就无需生成，往上的&lt;code&gt;selectCol&lt;/code&gt;变量也无需生成，若也没用到分页器组件，则&lt;code&gt;page&lt;/code&gt;分页器变量也无需声明，且&lt;code&gt;tableHook&lt;/code&gt;的声明以及他的&lt;code&gt;import&lt;/code&gt;导入可能都是多余的。&lt;/p&gt;
&lt;p&gt;如果需要精细化的判断，那么&lt;code&gt;if&lt;/code&gt;语句会非常多非常复杂，还是尽量用工具自动化处理这些&lt;/p&gt;
&lt;h3&gt;eslint autofix&lt;/h3&gt;
&lt;p&gt;https://eslint.org/docs/latest/rules/no-unused-vars&lt;/p&gt;
&lt;p&gt;官方有规则报错，但是没有自动修复，所以需要人工写一个 fixer 规则去自动删除无用变量&lt;/p&gt;
</content:encoded></item><item><title>从页面元素定位到源码位置</title><link>https://dabuside.github.io/posts/ext-dev-tools/</link><guid isPermaLink="true">https://dabuside.github.io/posts/ext-dev-tools/</guid><description>ext dev tools</description><pubDate>Tue, 22 Jun 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Contents&lt;/h2&gt;
&lt;h2&gt;快乐划水&lt;/h2&gt;
&lt;p&gt;今天上班划水，看到一个很有意思的文章&lt;a href=&quot;https://juejin.cn/post/6901466406823575560&quot;&gt;我点了页面上的元素，VSCode 乖乖打开了对应的组件？原理揭秘。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然&lt;code&gt;vue-dev-tools&lt;/code&gt;早就支持这个功能，但是看到这个&lt;code&gt;react&lt;/code&gt;版本的实现的细节，我才知道原理，简单概况一下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在编译的过程中，&lt;code&gt;babel&lt;/code&gt; 解析 &lt;code&gt;ast&lt;/code&gt;，遇到 &lt;code&gt;JSXOpeningElement&lt;/code&gt; 这个 &lt;code&gt;node&lt;/code&gt; 的 &lt;code&gt;type&lt;/code&gt; 的时候，注入当前源码行、列、文件到节点信息&lt;code&gt;fiber node&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;外部通过 &lt;code&gt;chrome插件&lt;/code&gt; 或者 用户代码注入一个事件，用户手动触发点击节点，从用户点击的节点中查找&lt;em&gt;步骤1&lt;/em&gt;中注入的信息，如果找到了，那么往本机发送一个请求&lt;/li&gt;
&lt;li&gt;本机启动一个服务。用于接受上述&lt;em&gt;步骤2&lt;/em&gt;发来的请求。当接受到请求的时候，监测本机常用的 &lt;code&gt;IDE&lt;/code&gt; 进程是否打开，调用系统命令打开对应 &lt;code&gt;IDE&lt;/code&gt; ，若都没找到则 fallback 记事本打开&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::NOTE
吐槽一下，我测试的时候怎么经常 fallback 到记事本打开，我 IDE 开着呢
:::&lt;/p&gt;
&lt;h2&gt;简单实现&lt;/h2&gt;
&lt;p&gt;现在项目中用的都是&lt;code&gt;Ext&lt;/code&gt;，老东西是没有 &lt;code&gt;dev-tools&lt;/code&gt; 的，找页面代码也是十分痛苦，我也准备搞一个自己的 &lt;code&gt;ext-dev-tool&lt;/code&gt; 插件&lt;/p&gt;
&lt;p&gt;整体流程与上述类似&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;dev&lt;/code&gt; 场景，在 &lt;code&gt;babel&lt;/code&gt; 编译的过程中，遇到 &lt;code&gt;new&lt;/code&gt; 组件的声明语句的时候、遇到 &lt;code&gt;xtype&lt;/code&gt; 节点声明的时候，注入当前源码行、列、文件到节点信息&lt;/li&gt;
&lt;li&gt;用户触发 &lt;code&gt;dev-tool&lt;/code&gt; 查询，使用&lt;code&gt;closest()&lt;/code&gt;定位到最近的元素，通过&lt;code&gt;Ext.get(id)&lt;/code&gt;获得组件实例&lt;/li&gt;
&lt;li&gt;在实例上查找1中注入的源码位置信息，若没有查到，则查询当前节点的父节点，直到父节点是 &lt;code&gt;body&lt;/code&gt; 为止&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;webpack devserver&lt;/code&gt; 接受上述3发送来的源码位置信息，调用命令行使用 &lt;code&gt;websotrm&lt;/code&gt; 打开文件&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;webstorm64.exe [--line &amp;lt;number&amp;gt;] [--column &amp;lt;number&amp;gt;] &amp;lt;path ...&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;咱们的组件声明场景大致如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;xtype.png&quot; alt=&quot;xtype&quot; /&gt;&lt;/p&gt;
&lt;p&gt;简单的注入 &lt;code&gt;babel&lt;/code&gt; 插件实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;babel.png&quot; alt=&quot;babel&quot; /&gt;&lt;/p&gt;
&lt;p&gt;至于&lt;code&gt;dev server&lt;/code&gt; 接受请求自动打开 IDE，适配不同 IDE 命令行的文件、loc位置信息传参，直接抄 &lt;a href=&quot;https://github.com/yyx990803/launch-editor&quot;&gt;vite源码实现&lt;/a&gt;，真是方便，感谢yyx&lt;/p&gt;
&lt;p&gt;实测，最终大概有 70% 的节点可以被注入源码信息，剩下 30% 的节点创造语句太复杂了，就不注入了。。。&lt;/p&gt;
</content:encoded></item><item><title>在 JavaScript 模块中导入非 JavaScript 资源</title><link>https://dabuside.github.io/posts/import_attributes/</link><guid isPermaLink="true">https://dabuside.github.io/posts/import_attributes/</guid><description>Import Assertions Syntax</description><pubDate>Tue, 28 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Contents&lt;/h2&gt;
&lt;h2&gt;导入断言（Import Assertions）&lt;/h2&gt;
&lt;p&gt;最初的 &lt;code&gt;Import Assertions&lt;/code&gt; 导入断言提案规定 &lt;code&gt;JavaScript&lt;/code&gt; 模块能够通过显式的类型断言来导入非 &lt;code&gt;JavaScript&lt;/code&gt; 资源。这对于处理各种类型的模块（尤其是 &lt;code&gt;JSON&lt;/code&gt; 模块）非常重要。&lt;/p&gt;
&lt;p&gt;其语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import json from &quot;./foo.json&quot; assert { type: &quot;json&quot; };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::note
&lt;code&gt;Import Assertions&lt;/code&gt;语法提案在&lt;code&gt;v8引擎 v12.3&lt;/code&gt;实装，计划于&lt;code&gt;v12.6&lt;/code&gt;版本取消对应的支持。&lt;/p&gt;
&lt;p&gt;2020 年 9 月，&lt;code&gt;Import Assertions&lt;/code&gt;提案更新由&lt;code&gt;Stage 2&lt;/code&gt;阶段进入&lt;code&gt;Stage 3&lt;/code&gt;阶段&lt;/p&gt;
&lt;p&gt;2023 年 2 月，&lt;code&gt;Import Assertions&lt;/code&gt;提案更新为导入属性&lt;code&gt;Import Attributes&lt;/code&gt;，并从&lt;code&gt;Stage 3&lt;/code&gt;阶段撤回至&lt;code&gt;Stage 2&lt;/code&gt;，极为少见的撤回了多个浏览器引擎已经支持的特性语法提案&lt;/p&gt;
&lt;p&gt;2023 年 3 月，&lt;code&gt;Import Assertions&lt;/code&gt;提案更新为&lt;code&gt;Import Attributes&lt;/code&gt;，并进入&lt;code&gt;Stage 3&lt;/code&gt;阶段&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h3&gt;导入断言（Import Assertions）提案的初衷&lt;/h3&gt;
&lt;p&gt;然而，有人担心在导入 &lt;code&gt;JSON&lt;/code&gt; 模块和无法执行代码的类似模块类型时可能会发生权限提升。当脚本导入它打算作为 &lt;code&gt;JSON&lt;/code&gt; 模块的内容时，如果响应服务器意外提供了不同的 &lt;code&gt;MIME&lt;/code&gt; 类型，则可能会导致代码意外执行。解决方案是在 &lt;code&gt;MIME&lt;/code&gt; 类型之外的某个地方以某种方式指示模块是 &lt;code&gt;JSON&lt;/code&gt;，或者一般来说，不执行。导入断言提供了这样做的方法。除了 &lt;code&gt;JSON&lt;/code&gt; 模块之外，受此安全问题阻止的拟议 &lt;code&gt;ES&lt;/code&gt; 模块类型还包括 &lt;code&gt;CSS&lt;/code&gt; 模块和可能的 &lt;code&gt;HTML&lt;/code&gt; 模块。&lt;/p&gt;
&lt;h3&gt;导入断言（Import Assertions）存在的问题&lt;/h3&gt;
&lt;p&gt;但是，仅断言语义有一个致命缺陷。在 Web 上，&lt;code&gt;HTTP&lt;/code&gt; 请求的形状因所请求资源的类型而异。例如，标头&lt;code&gt;Accept&lt;/code&gt;会影响响应的 &lt;code&gt;MIME&lt;/code&gt; 类型，而&lt;code&gt;Sec-Fetch-Dest&lt;/code&gt;元数据标头会影响 Web 服务器是接受还是拒绝请求。由于导入断言无法影响如何加载模块，因此它无法更改 HTTP 请求的形状。所请求资源的类型还会影响使用哪些内容安全策略：导入断言无法与 Web 的安全模型正确配合使用。&lt;/p&gt;
&lt;h2&gt;更新后的提案：导入属性（Import Attributes）&lt;/h2&gt;
&lt;h3&gt;新语法&lt;/h3&gt;
&lt;p&gt;将关键字从&lt;code&gt;assert&lt;/code&gt;更改为&lt;code&gt;with&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import json from &quot;./foo.json&quot; with { type: &quot;json&quot; };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;动态导入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import(&quot;foo.json&quot;, { with: { type: &quot;json&quot; } })
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;差异与改进&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;允许&lt;code&gt;Import Assertions&lt;/code&gt;导入属性影响模块加载&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是 TC39 根据 HTML 反馈制定的主要目标。属性现在可以成为缓存键的一部分（以前可以，但不鼓励这样做），并且它们可用于影响模块的获取/解释方式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽早规定不支持属性导入的异常抛出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了最大限度地提高可移植性，导入断言提案的先前版本忽略了主机不支持的任何断言。这是最好的选择，因为除非有人明确期望断言抛出，否则可以继续跨环境工作。现在导入属性可以改变导入模块的结果，忽略它们可能会完全改变模块的运行时行为（例如想想&lt;code&gt;type: &quot;css-inject-global&quot;&lt;/code&gt;vs &lt;code&gt;type: &quot;css-module&quot;&lt;/code&gt;），最好尽早抛出出错。&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://v8.dev/features/import-attributes&lt;/li&gt;
&lt;li&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&lt;/li&gt;
&lt;li&gt;https://github.com/tc39/proposal-import-attributes&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>javascript 绕过反调试</title><link>https://dabuside.github.io/posts/javascript_anti_anti_debug/</link><guid isPermaLink="true">https://dabuside.github.io/posts/javascript_anti_anti_debug/</guid><pubDate>Thu, 10 Mar 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Contents&lt;/h2&gt;
&lt;p&gt;直接绕过三种反调试&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无限 &lt;code&gt;debugger&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;getter 陷阱&lt;/li&gt;
&lt;li&gt;无限 &lt;code&gt;console.clear()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;https://chromewebstore.google.com/detail/anti-anti-debug/mnmnmcmdkigakhlfkcdimghndnmomfeo&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>javascript 反调试</title><link>https://dabuside.github.io/posts/javascript_anti_debug/</link><guid isPermaLink="true">https://dabuside.github.io/posts/javascript_anti_debug/</guid><pubDate>Thu, 10 Mar 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Contents&lt;/h2&gt;
&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;js&lt;/code&gt; 代码在客户端运行，&lt;code&gt;chrome dev tools&lt;/code&gt;提供了完善的调试能力。&lt;/p&gt;
&lt;p&gt;假如要做一个考试系统或者学习系统，客户端代码必然掺杂许多内部实现逻辑，如题目下发，做题，提交答案等等。开发者肯定是不想让第三方了解内部实现原理。&lt;/p&gt;
&lt;p&gt;这里介绍几种 &lt;code&gt;js&lt;/code&gt; 反调试技术。如检测调试到就上报系统、检测调试到页面就清空不运行等等，增大破解难度。&lt;/p&gt;
&lt;p&gt;:::tip
当破解成本大于自身信息价值的时候，那么就满足了计算安全，破解者就少。
:::&lt;/p&gt;
&lt;h2&gt;Time Diff&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var startTime = performance.now();
startMaliciousCode();
var stopTime = performance.now();
if ((stopTime - startTime) &amp;gt; 1000) {
    alert(&quot;Debugger detected!&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Chrome Getter&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;let div = document.createElement(&apos;div&apos;);
console.log(div);
Object.defineProperty(div, &quot;id&quot;, {get: () =&amp;gt; { alert(&quot;Dev Tools detected!&quot;); }});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Code Integrity&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;function hashCode (s) {
    var hash = 0;
    if (s.length == 0) {
        return hash;
    }
    for (var i = 0; i &amp;lt; s.length; i++) {
        var char = s.charCodeAt(i);
        hash = ((hash&amp;lt;&amp;lt;5)-hash)+char;
        hash = hash &amp;amp; hash; // Convert to 32bit integer
    }
    return hash;
}

function start() {
    alert(&apos;steal cookies!&apos;);
}

function main() {
    if (hashCode(start.toString()) !== -1968638942) return;
    start();
}

main()
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>在 Ext 中使用 JSX</title><link>https://dabuside.github.io/posts/jsx_in_ext_docs/</link><guid isPermaLink="true">https://dabuside.github.io/posts/jsx_in_ext_docs/</guid><description>ext in jsx</description><pubDate>Thu, 30 Apr 2020 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Contents&lt;/h2&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;Ext 这个框架真的不好用。。。&lt;/p&gt;
&lt;p&gt;平常就是用一大串 &lt;code&gt;json&lt;/code&gt; 去渲染一个表单，&lt;code&gt;json&lt;/code&gt; 这个格式对人实在不友好，只要内容一多，马上眼花缭乱&lt;/p&gt;
&lt;p&gt;比如一个简单的 &lt;code&gt;radiogroup&lt;/code&gt; 的声明 &lt;code&gt;json&lt;/code&gt; 如下。眼睛都要看花了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;form.items = [{
  xtype: &quot;RadioGroup&quot;,
  itemId: &quot;ext-jsx&quot;,
  vmodel: long_varable_name,
  name: _(&apos;nice boat&apos;),
  items: [{
    xtype: &quot;Radio&quot;,
    checkedValue: &quot;A&quot;,
    defaultChecked: true
  }, {
    xtype: &quot;Radio&quot;,
    checkedValue: &quot;B&quot;
  }, {
    xtype: &quot;Radio&quot;,
    checkedValue: &quot;C&quot;
  }, {
    xtype: &quot;RadioGroup&quot;,
    items: [{
      xtype: &quot;Radio&quot;,
      checkedValue: &quot;D&quot;
    }, {
      xtype: &quot;Radio&quot;,
      checkedValue: &quot;E&quot;,
      items: [{
        xtype: &quot;myCustomInnerXtype&quot;
      }]
    }]
  }]
}, new Grid({
  ext_in_jsx: &apos;awesome&apos;
})];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上一份工作用的是 &lt;code&gt;react&lt;/code&gt;，我还是觉得类 &lt;code&gt;html&lt;/code&gt; 的语言同来描述页面最适合不过了&lt;/p&gt;
&lt;p&gt;如果上述的 &lt;code&gt;json&lt;/code&gt; 用 &lt;code&gt;jsx&lt;/code&gt; 语法来描述的话，只需要 14 行，瞬间少了一半多有没有&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;form.items =
&amp;lt;&amp;gt;
  &amp;lt;RadioGroup itemId=&quot;ext-jsx&quot; vmodel={long_varable_name} name={_(&apos;nice boat&apos;)}&amp;gt;
    &amp;lt;Radio checkedValue=&quot;A&quot; defaultChecked&amp;gt;&amp;lt;/Radio&amp;gt;
    &amp;lt;Radio checkedValue=&quot;B&quot;&amp;gt;&amp;lt;/Radio&amp;gt;
    &amp;lt;Radio checkedValue=&quot;C&quot;&amp;gt;&amp;lt;/Radio&amp;gt;
    // i am comment
    &amp;lt;RadioGroup&amp;gt;
      &amp;lt;Radio checkedValue=&quot;D&quot;&amp;gt;&amp;lt;/Radio&amp;gt;
      &amp;lt;Radio checkedValue=&quot;E&quot;&amp;gt;&amp;lt;myCustomInnerXtype/&amp;gt;&amp;lt;/Radio&amp;gt;
    &amp;lt;/RadioGroup&amp;gt;
  &amp;lt;/RadioGroup&amp;gt;
  {new Grid({ext_in_jsx: &apos;awesome&apos;})}
&amp;lt;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自己写了一个 &lt;code&gt;babel&lt;/code&gt; 插件，可以将 &lt;code&gt;jsx&lt;/code&gt; 语法编译成类似 &lt;code&gt;Ext&lt;/code&gt; 中的表单渲染 &lt;code&gt;json&lt;/code&gt; 对象&lt;/p&gt;
&lt;h2&gt;效果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;preview.png&quot; alt=&quot;preview&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;在线玩一下&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://dabuside.github.io/jsx_in_ext/&quot;&gt;https://dabuside.github.io/jsx_in_ext/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;::github{repo=&quot;dabuside/jsx_in_ext&quot;}&lt;/p&gt;
</content:encoded></item><item><title>纯浏览器完成手写数字识别</title><link>https://dabuside.github.io/posts/mnist_broswer_docs/</link><guid isPermaLink="true">https://dabuside.github.io/posts/mnist_broswer_docs/</guid><description>mnist-broswer-pure</description><pubDate>Thu, 30 Nov 2017 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Contents&lt;/h2&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;组里要求全员学习AI&lt;/p&gt;
&lt;p&gt;学了一点 &lt;a href=&quot;https://cs231n.stanford.edu/index.html&quot;&gt;Computer Vision&lt;/a&gt; 和 &lt;a href=&quot;https://www.tensorflow.org/js&quot;&gt;TensorFlow&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;秉着试一试的精神，用了&lt;code&gt;tfjs&lt;/code&gt;做了一个纯浏览器版本的手写数字识别&lt;/p&gt;
&lt;p&gt;训练部分与预测部分均在浏览器端完成&lt;/p&gt;
&lt;h2&gt;效果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;preview.gif&quot; alt=&quot;preview&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;在线玩一下&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://dabuside.github.io/mnist-browser/&quot;&gt;https://dabuside.github.io/mnist-browser/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;::github{repo=&quot;dabuside/mnist-browser&quot;}&lt;/p&gt;
</content:encoded></item><item><title>pnpm lockfile 的不兼容性</title><link>https://dabuside.github.io/posts/pnpm_lockfile_version/</link><guid isPermaLink="true">https://dabuside.github.io/posts/pnpm_lockfile_version/</guid><pubDate>Sun, 22 Oct 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Contents&lt;/h2&gt;
&lt;h2&gt;问题&lt;/h2&gt;
&lt;p&gt;由于 &lt;code&gt;npm&lt;/code&gt; 包管理工具较为低效，前端圈出现了很多热门的第三方包管理工具。&lt;/p&gt;
&lt;p&gt;如&lt;code&gt;pnpm&lt;/code&gt;，&lt;code&gt;yarn&lt;/code&gt;。这些依赖包管理工具为了高效安装、解析依赖包，均会生成独特的&lt;code&gt;lock&lt;/code&gt;锁文件。用来指定一个项目中成千上万直接依赖包、间接依赖包的版本信息。&lt;/p&gt;
&lt;p&gt;然而，这些独特的&lt;code&gt;lock&lt;/code&gt;锁文件不仅无法跨工具兼容，还经常无法同工具跨版本兼容。即导致安装后依赖的版本与锁文件的版本不一致，导致项目无法启动。&lt;/p&gt;
&lt;p&gt;如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pnpm&lt;/code&gt; 生成的 &lt;code&gt;pnpm-lock.yaml&lt;/code&gt; 文件，无法被&lt;code&gt;yarn&lt;/code&gt;，&lt;code&gt;npm&lt;/code&gt;等工具 1:1兼容，需要使用 &lt;code&gt;pnpm&lt;/code&gt; 才能安装&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pnpm v6.35.1&lt;/code&gt; 生成的 &lt;code&gt;pnpm-lock.yaml&lt;/code&gt; 文件 &lt;code&gt;lockfileVersion: 5.3&lt;/code&gt;，无法被高版本 &lt;code&gt;pnpm v7&lt;/code&gt; 读取，也无法被低版本 &lt;code&gt;pnpm v5&lt;/code&gt; 读取，甚至跨中版本仍有可能读取失败。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;:::caution
&lt;code&gt;pnpm&lt;/code&gt; 锁因为不兼容而读取解析失败的时候，会无视锁文件信息，重新解析依赖关系，并再次生成&lt;code&gt;lockfile&lt;/code&gt;。因此，很多项目换包管理器版本重装依赖后，会导致项目无法启动
:::&lt;/p&gt;
&lt;p&gt;公司内部项目众多，有的工程需要使用&lt;code&gt;pnpm@6.35.1&lt;/code&gt;，有的要使用&lt;code&gt;pnpm@8.5.1&lt;/code&gt;，有的要使用&lt;code&gt;yarn@classic&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;A项目需要 &lt;em&gt;pnpm@6.35.1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;B项目需要 &lt;em&gt;pnpm@8.5.1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;C项目要需要 &lt;em&gt;yarn@classic&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;由于包管理工具是全局安装的，如果出现两个项目，需要同一个包管理工具的不同版本时，就需要重新安装对应版本的依赖工具，再进行依赖安装、更新。十分麻烦，而且经常会忘记。若使用了错误的包管理工具进行安装依赖，会导致整个依赖树被重新创建，还得删除整个&lt;code&gt;node_modules&lt;/code&gt;后切换正确的包管理工具再进行安装依赖。&lt;/p&gt;
&lt;h2&gt;解决方案&lt;/h2&gt;
&lt;p&gt;对此，&lt;code&gt;node&lt;/code&gt; 官方开发了 &lt;a href=&quot;https://github.com/nodejs/corepack&quot;&gt;corepack&lt;/a&gt; 包管理工具。在安装、更新依赖之前，可以自动下载（激活）指定的包管理工具，再进行安装。即可实现同时使用一个包管理工具的不同版本。&lt;/p&gt;
&lt;p&gt;我们仅需 &lt;code&gt;node &amp;gt; 14.19.0&lt;/code&gt; 并启用 &lt;em&gt;corepack&lt;/em&gt;  &lt;code&gt;corepack enable&lt;/code&gt;。
随后在&lt;code&gt;package.json&lt;/code&gt;文件写入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &quot;packageManager&quot;: &quot;&amp;lt;package manager name&amp;gt;@&amp;lt;version&amp;gt;&quot;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如&lt;code&gt;&quot;packageManager&quot;: &quot;pnpm@8.5.1&quot;&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;内网使用&lt;/h2&gt;
&lt;p&gt;当&lt;code&gt;corepack&lt;/code&gt;遇到指定的包管理版本工具，本地不存在的时候，&lt;code&gt;corepack&lt;/code&gt;便会尝试从官方源&lt;code&gt;https://registry.npmjs.org/&lt;/code&gt;获取。&lt;code&gt;corepack&lt;/code&gt;支持更换源，但是我们内网源的网络协议是&lt;code&gt;http&lt;/code&gt;的。&lt;code&gt;corepack&lt;/code&gt;并没有提供支持 &lt;a href=&quot;https://github.com/nodejs/corepack/issues/293&quot;&gt;issue&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;:::note
内网开发真是艰难，很多问题根本不是问题，但是在内网就是个大坑
:::&lt;/p&gt;
&lt;p&gt;对于离线安装，&lt;code&gt;corepack&lt;/code&gt;提供了&lt;code&gt;hydrate&lt;/code&gt;的安装形式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在能联网的电脑，执行&lt;code&gt;corepack prepare &amp;lt;package manager name&amp;gt;@&amp;lt;version&amp;gt; -o &lt;/code&gt;并将生成的文件&lt;code&gt;corepack.tgz&lt;/code&gt;拷贝至内网&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在内网，执行&lt;code&gt;corepack hydrate &amp;lt;path/to/corepack.tgz&amp;gt;&lt;/code&gt;，即可离线安装对应版本的包管理工具。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至此，在指定了&lt;code&gt;packageManager&lt;/code&gt;的项目内安装依赖，&lt;code&gt;corepack&lt;/code&gt;会自动切换到所需的版本，从而保证安装出正确的依赖。&lt;/p&gt;
</content:encoded></item><item><title>巨型项目重构记录（构建工具）</title><link>https://dabuside.github.io/posts/refactor_a_big_project_bundler/</link><guid isPermaLink="true">https://dabuside.github.io/posts/refactor_a_big_project_bundler/</guid><description>Webpack 迁移 Vite</description><pubDate>Sun, 20 Mar 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Contents&lt;/h2&gt;
&lt;h2&gt;大坑&lt;/h2&gt;
&lt;p&gt;接手了一个历史 10+ 年，200+ 页面路由，js 文件 3000+，css/less 文件 2000+ 的巨型后台管理系统。它的脚手架是公司内部定制的&lt;code&gt;sfx&lt;/code&gt;，即深度封装的&lt;code&gt;webpack4&lt;/code&gt;。他的界面是长这个样子的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image.png&quot; alt=&quot;ui&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如下问题十分影响开发效率&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;项目 dev 时间在 3-4 min，修改 js 文件的 HMR 热更新时间基本在 30s+&lt;/li&gt;
&lt;li&gt;业务框架为 Ext，新人上手成本极大，老人的开发效率也不如现代框架&lt;/li&gt;
&lt;li&gt;CI 时间非常久，普遍需要 40 min&lt;/li&gt;
&lt;li&gt;由于组件库框架使用 js 实现了一套样式系统，适配不同国际化语言需要编写侵入性代码，无法做到语言配置与代码隔离&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;入项一年多后，准备进行大刀阔斧的改进&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;尝试 Webpack 调优&lt;/h2&gt;
&lt;p&gt;挂载 Webpack 性能检测 &lt;a href=&quot;https://github.com/stephencookdev/speed-measure-webpack-plugin&quot;&gt;SMP 插件&lt;/a&gt;，校验 dev time 各个任务的运行时间&lt;/p&gt;
&lt;p&gt;插件统计出的各个 loader 与 plugin 的运行时间如下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;统计插件本身会影响性能。总运行时间之和会大于总时间，因为任务是并行的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;dev 启动总时间 4 min+&lt;/li&gt;
&lt;li&gt;happypack + babel-loader + eslint-loader + vue-loader + ts-loader ~ 2~3 min (with cache)&lt;/li&gt;
&lt;li&gt;css-loader + postcss-loader + less-loader + style-loader ~ 1-2 min (without cache)&lt;/li&gt;
&lt;li&gt;file-loader + url-loader + svgo-loader ~ 1 min&lt;/li&gt;
&lt;li&gt;progress plugin ~ 4 min（progress 插件一直在运行，故 plugin 运行时间 === 总时间）&lt;/li&gt;
&lt;li&gt;sourcemap 生成没有在统计范围内，肉眼察觉在 30s&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中，js 相关 loader 处理文件 2000+，css 相关 loader 处理文件 1000+，可以明显察觉，dev 的启动瓶颈在于需要处理的文件太多了。即使有了缓存，速度仍然不理想。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;热更新 css 文件，大多是毫秒级响应。热更新 js 文件，大多数场景所需处理的文件仅少一两个量级，有 1/3 时间消耗在 sourcemap 生成&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;核心问题在于 Webpack 对于懒编译支持很差。即无法按需编译。由于 200+页面路由全部都是懒加载的，完全可以访问到对应路由，再进行编译相关文件，无需提前将 200+路由页面事先编译好再启动。&lt;a href=&quot;https://webpack.js.org/configuration/experiments/#experimentslazycompilation&quot;&gt;webpack5.4 之后实验性支持懒编译&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;根据 &lt;a href=&quot;https://webpack.js.org/guides/build-performance/&quot;&gt;Webpack 官方调优指南&lt;/a&gt; 进行优化&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;升级 Webpack 到最新版&lt;/li&gt;
&lt;li&gt;精简 loader、plugin&lt;/li&gt;
&lt;li&gt;第三方包 DLL 预编译&lt;/li&gt;
&lt;li&gt;多线程&lt;/li&gt;
&lt;li&gt;缓存&lt;/li&gt;
&lt;li&gt;去除进度插件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实验效果如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直接升级到 Webpack5 报错很多跑不动，短时间改不好，先搁置&lt;/li&gt;
&lt;li&gt;去掉了没用的 loader，提升不明显&lt;/li&gt;
&lt;li&gt;sfx 已集成预编译&lt;/li&gt;
&lt;li&gt;sfx 已集成多线程插件&lt;/li&gt;
&lt;li&gt;sfx 已集成缓存插件，修改 css 相关文件，热更新时间很短，暂时不加&lt;/li&gt;
&lt;li&gt;有用！去除进度插件可以节约 30s 左右的启动速度，dev 速度也有对应比例提升&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总体提升不明显，且热更新时间太长仍然是关键瓶颈。咨询公司内部其余采用 Webpack5 的大项目，热更新时间仍然不理想。看到 &lt;a href=&quot;https://github.com/sokra&quot;&gt;webpack 原作者&lt;/a&gt; 跑路去写 &lt;a href=&quot;https://github.com/vercel/turbo&quot;&gt;turbo&lt;/a&gt; ，以及 Vue CLI 进入维护模式，我觉得未来主流不会再是&lt;code&gt;Webpack&lt;/code&gt;，面对 3-5 年后的代码量增长，编译环节增加需求，还是尽早迁移到&lt;code&gt;Vite&lt;/code&gt;上比较好&lt;/p&gt;
&lt;h2&gt;尝试 vite&lt;/h2&gt;
&lt;p&gt;vite 使用 ESM 模块加载机制，热更新时候仅需更新少量文件，无需重新打包。且 vite 原生支持按需编译，即访问到某个页面，才会将需要的文件编译。&lt;/p&gt;
&lt;p&gt;为了升级到 vite ，需要解决如下问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ESM 所有模块均采用严格模式，原先存在很多非严格模式的用法，需要批量更新成严格模式&lt;/li&gt;
&lt;li&gt;原先代码的模块化方式是 CommonJS， 需要批量更新成 ESM&lt;/li&gt;
&lt;li&gt;他们配置文件上的差异转换，以及原先的 Webpack 插件重写成 rollup 插件&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;严格模式转换&lt;/h3&gt;
&lt;p&gt;Ext 框架是 09 年的产物，那时候还没有 ES6 继承相关的规范，为了在类之间方便创建继承关系，Ext 代码是这样描述继承的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var Page = simpleExtend(SF.BasePage, {
    onLayout: function() {
        // 效果类似于 this.super() 调用 SF.BasePage 父类的 onLayout 方法
        this.callparent();
        console.log(&apos;custom layout&apos;);
    },
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;this.callparent&lt;/code&gt;的本质是通过&lt;code&gt;Function.prototype.caller&lt;/code&gt;这种&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/caller&quot;&gt;非严格模式&lt;/a&gt;的寻址，找到父类的方法名并调用。等价于&lt;code&gt;this.callparent.caller.name.apply(this, arguments)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这种非严格模式调用，需要改成显式的对父级函数的调用，以满足严格模式（ES Modules）的要求&lt;/p&gt;
&lt;p&gt;所以，上述代码需要转换成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var Page = simpleExtend(SF.BasePage, {
    onLayout: function() {
        SF.BasePage.prototype.onLayout.apply(this);
        console.log(&apos;custom layout&apos;);
    },
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非严格模式继承 demo 如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function simpleExtend(base, props) {
    function NewConstructor() {
        base.apply(this, arguments);
    }

    NewConstructor.prototype = Object.create(base.prototype);
    NewConstructor.prototype.constructor = NewConstructor;

    for (var prop in props) {
        if (props.hasOwnProperty(prop)) {
            NewConstructor.prototype[prop] = props[prop];
        }
    }

    NewConstructor.prototype._parent = base.prototype

    return NewConstructor;
}

var SF = {
    BasePage: (function() {
        var f = function() {}
        f.prototype.onLayout = function onLayout() {
            console.log(&apos;base page layout&apos;)
        }
        f.prototype.hello = function onLayout() {
            console.log(&apos;hello&apos;)
        }
        f.prototype.callparent = function() {
            return this._parent?.[this.callparent.caller.name].apply(this, arguments);
        }
        return f
    }
    )()
}

var Page = simpleExtend(SF.BasePage, {
    onLayout: function() {
        // SF.BasePage.prototype.onLayout.apply(this, arguments)
        this.callparent();
        console.log(&apos;custom layout&apos;)
    },

    myFunc: function() {}
})

var p = new Page();
p.onLayout();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还可参见&lt;a href=&quot;https://cdn.sencha.com/ext/gpl/3.4.1.1/docs/source/Ext.html&quot;&gt;Ext 源码完整实现&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;Babel 插件&lt;/h4&gt;
&lt;p&gt;现在的问题就在于，项目中 2000+ 的 js 文件几乎每个都涉及到这种非严格模式调用，靠人工肯定是不现实的。最好是写一个插件批量完成这种的转换。&lt;/p&gt;
&lt;p&gt;其中，Babel 插件做这个最合适了。&lt;/p&gt;
&lt;p&gt;Babel 是一个编译器，他能将代码 code 转换为另一种形式的 code。大体流程如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const ast = parse(code);
const astTransformed = transform(ast);
const codeNew = generate(astTransformed);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们要做的就是编写一个 AST 转换插件，他会集成到&lt;code&gt;transform&lt;/code&gt;流程中，对 AST 进行修改，以达到最终效果。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this.callParent()&lt;/code&gt;在 AST 结构树中的表示如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;ast1.png&quot; alt=&quot;ast1&quot; /&gt;&lt;/p&gt;
&lt;p&gt;我们需要&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找到&lt;code&gt;this.callparent()&lt;/code&gt;的 AST 节点&lt;/li&gt;
&lt;li&gt;找到 Extend 继承的父类节点&lt;/li&gt;
&lt;li&gt;找到 Extend 继承的父类节点的方法&lt;/li&gt;
&lt;li&gt;根据2，3拿到的信息修改 1 节点的内容&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简易示例如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Identifier(path) {
    // 1. 找到`this.callparent()`的 AST 节点
    if (path.node.name === &quot;callparent&quot;) {

        // 2. 找到 Extend 继承的父类节点
        const extendPath = path.findParent(
            (p) =&amp;gt;
                p.node.type === &quot;CallExpression&quot; &amp;amp;&amp;amp;
                p.node.callee.name === &quot;simpleExtend&quot;,
        );
        const extendNode = extendPath.node.arguments[0];

        // 3. 找到 Extend 继承的父类节点的方法
        const methodPath = path.findParent(
            (p) =&amp;gt; p.node.type === &quot;ObjectProperty&quot;,
        );
        const methodString = methodPath.node.key.name;

        const extendString = `${extendNode.object.name}.${extendNode.property.name}.prototype.${methodString}.`;

        // 4. 根据 methodPath extendPath 拿到的信息修改 1 节点的内容
        path.parentPath.parentPath.replaceWithSourceString(
            `${extendString}apply(this)`,
        );
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://astexplorer.net/#/gist/d56c1a29f344c5c6b73cf316e08a93a9/138db87532b490f063cacb23d47cb121f47ae6b5&quot;&gt;示例playground&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;Edge Case&lt;/h4&gt;
&lt;p&gt;写这种转换插件，大约 20% 的时间是用在写最常规的流程的，其余 80% 的时间都是处理 Edge Case 的，项目只要一大，就会发现什么写法都有&lt;/p&gt;
&lt;p&gt;父类指向不清晰&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let grid = new Ext.extend(SF.grid.GeneralGrid, {
    initComponent: function () {
        this.portDisplayField = this._createDisplayField({
            setWidth () {
                this.callParent([0]);
            }
        });
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数入参使用 Default parameters 语法，解构等语法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let Win = Ext.extend(SF.form.FormWindow, {
    constructor (cfg = {}) {
        cfg.form = new Form();
        this.callParent([cfg]);
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非赋值语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new Ext.extend(ContainerCombo, {
    expand () {
        this.callParent();
        this.reload();
    },
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;... 太多了。&lt;/p&gt;
&lt;p&gt;我开始能理解 eslint 规则为什么不好写了。举个例子，未声明变量提示，&lt;a href=&quot;https://github.com/eslint/eslint/blob/main/tests/lib/rules/no-unused-vars.js&quot;&gt;代码&lt;/a&gt;只需要 800 行，但是&lt;a href=&quot;https://github.com/eslint/eslint/blob/main/lib/rules/no-unused-vars.js&quot;&gt;测试用例&lt;/a&gt;足足有 1800 行&lt;/p&gt;
&lt;p&gt;还能说啥呢，只能是一个一个加到测试用例里面，继续爬坑。&lt;/p&gt;
&lt;h4&gt;Recast&lt;/h4&gt;
&lt;p&gt;好不容易吧所有场景的转换都处理完，又发现一个问题。明明一个文件只修改了少了的 AST 节点内容，怎么最终生成的文件有巨大的 diff 差异？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;diff-large.png&quot; alt=&quot;diff-large&quot; /&gt;&lt;/p&gt;
&lt;p&gt;项目中没有引用 prettier 等统一格式化工具，只有 eslint autofix。重新 eslint 排版后，仍有大量差异信息。应该是 Babel 在 generate 流程，将所有 AST 当作全新的 AST 去生成了。因为项目组里面有 20 来个人，我这 diff 差异太大的话，会给组内其他人员上库代码造成严重的冲突问题。必须要解决一下。&lt;/p&gt;
&lt;p&gt;通过一番搜索，了解到有这样一个工具 &lt;code&gt;Recast&lt;/code&gt;，它可以实现精准修改特定 AST 节点，而不影响其他节点，集成到 babel 中也特别方便。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { parse, print } from &quot;recast&quot;;
import { transformFromAstSync } from &quot;@babel/core&quot;;
export function babelRecast(code) {
  const ast = parse(code, { parser: require(&quot;recast/parsers/babel&quot;) });
  const options = { plugins: [updateContent] };
  const { ast: transformedAST } = transformFromAstSync(ast, code, options);
  const result = print(transformedAST).code;
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Recast 的原理就是对比修改前后的 AST 节点信息，找到被修改的 AST 节点，再进行精准修改。&lt;/p&gt;
&lt;p&gt;而 Babel 则是直接根据修改后的 AST 节点（丢弃 loc 位置信息）重新生成代码。&lt;/p&gt;
&lt;p&gt;最终的效果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;diff-small.png&quot; alt=&quot;diff-small&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;CommonJS 批量转 ESM&lt;/h3&gt;
&lt;p&gt;由于 CommonJS 的导入导出语法比上述场景多得多，自己短时间内完整实现一套 AST 转换不现实。且市面上有很多 CJS 转 ESM 的工具，秉着不造轮子的理念，逐一尝试了 star 较多或者 npm download 数量较大的开源方案&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://github.com/lebab/lebab&lt;/li&gt;
&lt;li&gt;https://github.com/5to6/5to6-codemod&lt;/li&gt;
&lt;li&gt;https://github.com/wessberg/cjstoesm&lt;/li&gt;
&lt;li&gt;https://github.com/tnfe/wp2vite&lt;/li&gt;
&lt;li&gt;https://www.npmjs.com/package/@rollup/plugin-commonjs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是没有一个能完美解决项目里面的场景的。甚至不少开源转换方案，在最基本的导入导出场景都错误处理。&lt;/p&gt;
&lt;h4&gt;模块导入导出的关键差异&lt;/h4&gt;
&lt;p&gt;最主要的问题在于&lt;code&gt;require&lt;/code&gt;相关的语法是&lt;strong&gt;运行时&lt;/strong&gt;决定哪些模块导入导出的，而&lt;code&gt;import&lt;/code&gt;相关语法是&lt;strong&gt;编译时&lt;/strong&gt;决定哪些模块导入导出的。&lt;/p&gt;
&lt;p&gt;举个例子，模块 A 使用 CJS 语法声明了一个导出对象 obj&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var obj = {
	foo() {
		return 2 + 2;
	},
	bar: 3,
	baz: new RegExp(&quot;&quot;)
};
module.exports = obj;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模块 B 中这些 CJS 导入都是合法的，即便没有显式声明这部分导出，因为这部分是运行时的函数调用而已&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var pkg = require(&apos;b.js&apos;);
var { foo } = require(&apos;b.js&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若上述导出代码转换为 ESM，则应为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export function foo() {
	return 2 + 2;
}
export const bar = 3;
export const baz = new RegExp(&quot;&quot;);
export default { foo, bar, baz };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即如何处理导出模块，与导入上使用的语法关系相当大。为了兼容&lt;em&gt;大部分&lt;/em&gt;导入场景，导出部分需要显式声明&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个子模块导出的内容，即&lt;code&gt;export const xxx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;默认导出的内容，即&lt;code&gt;export default xxx&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;且导入语法不能有多级解构&lt;/p&gt;
&lt;p&gt;如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const {
  a: { b: c },
} = require(&quot;b.js&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没有对于的 ESM 导入语法支持，只能处理成默认导出，并额外增加赋值语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import bMod from &apos;b.js&apos;;
const {
  a: { b: c },
} = bMod;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;过于高级的语法&lt;/h4&gt;
&lt;p&gt;由于项目中使用了一些 Stage 3 Proposal 的语法，如&lt;code&gt;??&lt;/code&gt;,&lt;code&gt;?.&lt;/code&gt;，导致很多转换器在解析环节生成 AST 就出错了，必须 fork 项目，进入源码，升级解析器才能支持将代码处理成 AST 节点树&lt;/p&gt;
&lt;h4&gt;Edge Case&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// condition import
const img = isEnglish ? require(&apos;img_en.jpg&apos;) ? : require(&apos;img_cn.jpg&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// unnamed import
const imgs = [require(&apos;1.jpg&apos;), require(&apos;2.jpg&apos;), require(&apos;3.jpg&apos;)];
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// direct import call
require(&apos;method.js&apos;)();
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// dynamic export
var obj = {
    b: 20
};
module.exports = {
    ...obj,
    a,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;处理方式&lt;/h4&gt;
&lt;p&gt;优先选择采用 jscodeshift 方案的代码。因为他们一般都有插件化，可以单独启用禁用某种转换逻辑。这样一种语法一种语法转换，不容易出错。每个开源方案都是部分正确的，需要吧正确的部分找出来，屏蔽错误的部分。再编码开源方案未解决的部分&lt;/p&gt;
&lt;p&gt;由于该部分的语法以及边界场景比上述严格模式转换要多得多，即使在有很多开源产品的帮助下，完成转换仍然花费了数倍与上述严格模式转换的时间&lt;/p&gt;
&lt;h2&gt;最终效果&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;热启动时间 30s&lt;/li&gt;
&lt;li&gt;HMR 时间 1s 内&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>巨型项目重构记录（CI流程）</title><link>https://dabuside.github.io/posts/refactor_a_big_project_ci/</link><guid isPermaLink="true">https://dabuside.github.io/posts/refactor_a_big_project_ci/</guid><description>makefile to simple shell script</description><pubDate>Tue, 22 Mar 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Contents&lt;/h2&gt;
&lt;h2&gt;历史问题&lt;/h2&gt;
&lt;p&gt;前后端没有分仓库管理的时候，前后端代码在同一个仓库内，且前后端构建在一个脚本内，由后端维护。&lt;/p&gt;
&lt;p&gt;现在前端仓库从后端代码仓独立之后，后端不太管这一块。出问题需要自行排查解决。遗留问题老大难了。&lt;/p&gt;
&lt;p&gt;原先的构建代码有 1000+ 行，而且还是以&lt;code&gt;makefile&lt;/code&gt;脚本写的，前端没人看得懂。。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CI实在卡的不行，一次少说 30 分钟。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;old_ci.png&quot; alt=&quot;old_ci_time&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原有CI流程也太多了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;process.png&quot; alt=&quot;process&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;梳理&lt;/h2&gt;
&lt;p&gt;经过痛苦的 &lt;code&gt;makefile&lt;/code&gt; 学习之后，我发现卡的原因在于&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在打包脚本里面写安装软件，跑CI都需要安装&lt;code&gt;node&lt;/code&gt;,&lt;code&gt;git&lt;/code&gt;,&lt;code&gt;yarn&lt;/code&gt;等软件&lt;/li&gt;
&lt;li&gt;CI是在 &lt;code&gt;shell runner&lt;/code&gt; 中执行的，而不是 &lt;code&gt;docker runner&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;怎么破局&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;对于前端构建来说哪些流程是必要的？===&amp;gt;构建、上传代码&lt;/li&gt;
&lt;li&gt;构建脚本中软件安装流程能否省略？===&amp;gt;迁移至docker image内&lt;/li&gt;
&lt;li&gt;代码可读性不佳，如何优化？===&amp;gt;重构、提供完整的文档&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;docker 简介&lt;/h2&gt;
&lt;h3&gt;什么是docker？&lt;/h3&gt;
&lt;p&gt;The Docker daemon（dockerd） docker服务端。主要功能是管理image container network等&lt;/p&gt;
&lt;p&gt;The Docker client（docker） Docker前端。大部分用户通过docker前端来操作docker。主要功能是和dockerd通讯。&lt;/p&gt;
&lt;p&gt;Docker registries 类似git，提供pull push commit tag等功能。主要是对docker image进行版本管理。&lt;/p&gt;
&lt;p&gt;Images 只读模板，类似虚拟机镜像（win7+ie8;win7+ie10）&lt;/p&gt;
&lt;p&gt;Containers 是 image 的可运行实例。&lt;/p&gt;
&lt;h3&gt;什么是 gitlab runner？&lt;/h3&gt;
&lt;p&gt;Runner是 gitlab ci cd 工作流钦定的执行套件。
&lt;img src=&quot;gitlab_runner.png&quot; alt=&quot;gitlab_runner&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;不同 executor 有什么区别&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;executor.png&quot; alt=&quot;executor&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;改造&lt;/h2&gt;
&lt;h3&gt;制作前端构建环境 docker 镜像&lt;/h3&gt;
&lt;p&gt;俺们吧所需的全部软件，安装到 docker 镜像里面，写成 docker file&lt;/p&gt;
&lt;p&gt;再上传到公司的 docker harbor 镜像仓库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;docker_harbor.png&quot; alt=&quot;docker_harbor&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;注册 docker gitlab runner 到项目&lt;/h3&gt;
&lt;h3&gt;迁移 1000+ 行 makefile 构建到 node script&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;yaml.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;最终效果&lt;/h2&gt;
&lt;p&gt;CI 流水线平均用时缩短 90%&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;new_ci.png&quot; alt=&quot;new_ci&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>巨型项目重构记录（框架）</title><link>https://dabuside.github.io/posts/refactor_a_big_project_framework/</link><guid isPermaLink="true">https://dabuside.github.io/posts/refactor_a_big_project_framework/</guid><description>Ext 迁移 Vue</description><pubDate>Mon, 21 Mar 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Contents&lt;/h2&gt;
&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;项目使用的 Ext 框架已经有10年以上历史。目前前端界知道使用过该框架的人非常少，而且难度大，导致上手成本非常高。一个从来没有做到 Ext 的新手至少要熟悉一个月以上，也只能处理纯粹的表单表格这种页面，对于稍微炫一点的页面无能为力，这时效率就非常低了。此前由于这些原因也导致人员培养困难、招不到人接手、公司内部只有少数前端熟悉该框架、新人较排斥。业务组之间协调人力由于框架上的差异也造成较大风险。&lt;/p&gt;
&lt;h2&gt;行动&lt;/h2&gt;
&lt;p&gt;重构不得不进行，有两种重构方式&lt;/p&gt;
&lt;p&gt;首先，由 &lt;code&gt;Framework&lt;/code&gt; 提供的基础功能有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路由&lt;/li&gt;
&lt;li&gt;全局数据&lt;/li&gt;
&lt;li&gt;页面导航框架&lt;/li&gt;
&lt;li&gt;全局告警&lt;/li&gt;
&lt;li&gt;页面多开&lt;/li&gt;
&lt;li&gt;10 more&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Ext 嵌入 Vue&lt;/h3&gt;
&lt;p&gt;Ext作为框架内嵌 vue&lt;/p&gt;
&lt;p&gt;用简单代码来描述的话，仅需改造&lt;code&gt;LazyPageLoader&lt;/code&gt;，使得它可以创建一个空白节点，装载&lt;code&gt;vue示例&lt;/code&gt;上去，并在全局数据变化的时候强制让&lt;code&gt;VuePage&lt;/code&gt;去&lt;code&gt;reload&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ExtFramework&amp;gt;
  &amp;lt;LazyPageLoader&amp;gt;
    &amp;lt;ExtPage1 /&amp;gt;
    &amp;lt;ExtPage2 /&amp;gt;
    &amp;lt;ExtPage3 /&amp;gt;
    &amp;lt;VuePage1 /&amp;gt;
  &amp;lt;/LazyPageLoader&amp;gt;
&amp;lt;/ExtFramework&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;前期风险较小，不需要改原始的项目框架，只针对新的模块创建一个 Ext 容器将 Vue 挂载进去&lt;/li&gt;
&lt;li&gt;最终并不能将 Ext 框架舍弃，首先你还是得会用 Ext 去创建一个页面&lt;/li&gt;
&lt;li&gt;项目里面很多复杂的业务组件，换vue不现实；不换最终将变成Ext里面插入vue，vue里面又插入Ext&lt;/li&gt;
&lt;li&gt;后面如果像去掉 Ext 外壳将对整个项目产生较大风险，测试量大。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Vue 嵌入 Ext&lt;/h3&gt;
&lt;p&gt;Ext作为框架内嵌 vue&lt;/p&gt;
&lt;p&gt;则需要改造全部由&lt;code&gt;Framework&lt;/code&gt;提供的能力，但是改造的也会更彻底&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;VueFramework&amp;gt;
  &amp;lt;LazyPageLoader&amp;gt;
    &amp;lt;VuePage1 /&amp;gt;
    &amp;lt;ExtLoader&amp;gt;
      &amp;lt;ExtPage1 /&amp;gt;
    &amp;lt;/ExtLoader&amp;gt;
    &amp;lt;ExtLoader&amp;gt;
      &amp;lt;ExtPage2 /&amp;gt;
    &amp;lt;/ExtLoader&amp;gt;
  &amp;lt;/LazyPageLoader&amp;gt;
&amp;lt;/VueFramework&amp;gt;;

&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;可将复杂的Ext业务组件直接用Vue包裹起来，不需要特意去维护。&lt;/li&gt;
&lt;li&gt;风险前移，只要前期预研方案产出充分，后期将基本不会对项目产生不可预知的风险，最终可实现逐步全部替换成新框架。&lt;/li&gt;
&lt;li&gt;需要将原项目中所有以前的Ext载入流程全换成vue&lt;/li&gt;
&lt;li&gt;原渲染形式将受较大影响&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;方案一属于风险前移型，前期做好充分的工作，后期将随心所欲；方案二属于风险后置型，要不就一直依附在Ext框架上，要不就后期处理原framework的逻辑&lt;/p&gt;
</content:encoded></item></channel></rss>